#### ES6

##### 作用域context

**声明变量的六种方法**

ES5只有var和function声明。ES6新增let，const，import和class

#### 顶层对象属性

顶层对象，在浏览器环境指的是`window`对象，在 Node 指的是`global`对象。顶层对象与全局变量挂钩是JS最大的败笔之一。

[ES2020](https://github.com/tc39/proposal-global) 在语言标准的层面，引入**globalThis**作为顶层对象。确保任何环境下，`globalThis`都是存在的，都可以从它拿到顶层对象，指向全局环境下的`this`。

**问题：**

+ 程序员很容易不知不觉地就创建了全局变量
+ 顶层对象的属性是到处可以读写的，这非常不利于模块化编程
+ 另一方面`window`对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。

ES6规定，`let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性。[储存在script不在global]也就是说，**从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。**

```js
var a = 1;window.a // 1  

let b = 1;window.b // undefined  不在顶层属性里了，在script里
```

#### 字符串数值主流新增方法

```javascript
Number.parseInt('12.34') // 12
Number.parseFloat('123.45#') // 123.4

Number.isInteger(25) // true
Number.isInteger(25.1) // false

let s = 'Hello world!';
s.startsWith('Hello') // true
s.endsWith('!') // true
s.includes('o') // true

```

#### 函数拓展

**可以指定默认值**

**与解构赋值结合使用**

```javascript
//注意这个是解构的默认赋值不是函数默认赋值
function foo({x, y = 5}) {console.log(x, y);}

foo({}) // undefined 5
foo({x: 1}) // 1 5
foo({x: 1, y: 2}) // 1 2
foo() // TypeError: Cannot read property 'x' of undefined
```

**rest参数**

`...变量名`可以获取多余的参数，这样就无须使用arguments对象。rest参数搭配了一个数组，arguments是类数组。rest 参数只能是最后一个参数。

```js
//必须使用Array.from先将类数组其转为数组。
// arguments变量的写法
function sortNumbers() {
  return Array.from(arguments).sort();
}

// rest参数的写法
const sortNumbers = (...numbers) => numbers.sort();
```

**aruguments**

类数组实际上是一个对象

```js
let arrayLike = {
  '0': 'a',
  '1': 'b',
  '2': 'c',
  length: 3
};
```



**箭头函数**

+ 无this，不可以当成构造函数，不能call，apply，bind
+ 不可以使用arguments，用rest代替
+ 不可以使用yield，不能用作Generator函数

+ 不适合场景
  + 对象方法不适合用箭头函数定义
  + 需要动态this比如监听事件click

```javascript
const cat = {lives: 9,
  jumps: () => {this.lives--;}}
//因为对象不构成单独作用域，jumps的this获取到的是全局

var button = document.getElementById('press');
button.addEventListener('click', () => {
  this.classList.toggle('on');
});//this永远指向globalThis

```

**调用栈/帧**

函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数`A`的内部调用函数`B`，那么在`A`的调用帧上方，还会形成一个`B`的调用帧。等到`B`运行结束，将结果返回到`A`，`B`的调用帧才会消失。如果函数`B`内部还调用函数`C`，那就还有一个`C`的调用帧，以此类推。**所有的调用帧，就形成一个“调用栈”**（call stack）。

递归非常耗费内存，**就是因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）**。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。

**柯里化**currying

多参函数转为单参函数

#### 拓展运算符

好比rest的逆运算，把一个数组转为用逗号分割的参数序列。

```js
console.log(...[1, 2, 3])// 1 2 3

Math.max(...[14, 3, 77]);// 等同于
Math.max(14, 3, 77);
```

**主要用途**

+ 合并数组`[...arr1,...arr2]`
+ 浅拷贝`[...arr1]`
+ 字符串转数组`[...'hello']`

#### 变量提升hoisting

var声明的变量被提升到当前作用域顶层，但是没有初始化。funct会提升并且初始化

JavaScript's default behavior of moving all declarations to the top of the current scope. JavaScript only hoists declarations, not initializations.













# 新知识点

yield

严格模式

