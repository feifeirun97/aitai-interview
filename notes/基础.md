# React

#### 虚拟DOM

##### 虚拟dom是什么？[document object model]

+ 在js和真实dom中间加了一个个缓存，利用dom diff算法避免了没有必要的dom操作，提高了性能

##### 实现过程

+ 用JS对象结构表示dom树的结构

+ 用这个树构建一个真正的dom树,插到文档中当状态变更时, 重新构造一颗新的对象树

+ 新旧对象树比较, 记录差异并把差异应用到1所构建的真正的dom树上, 视图就更新了

#### 虚拟dom和dom的区别 性能差异

减少dom操作虚拟dom可以将多次dom操作合并为一次操作

| Real dom            | Virtual dom       |
| :------------------ | :---------------- |
| 更新慢              | 更新快            |
| 可以直接更新html    | 无法直接更新html  |
| 元素更新创建新dom树 | 元素更新则更新JSX |
| dom操作代价高       | DOM操作简单       |
| 消耗内存多          | 内存消耗小        |

#### React组件间通讯

| 六种方式           | 实现 |
| ------------------ | ---- |
| 父组件向子组件通讯 |      |
|                    |      |
|                    |      |
|                    |      |
|                    |      |
|                    |      |



#### 防抖

减少用户触发，只要最后一次操作

```js
//有全局变量的方式
let inp = document.querySelector("input")
let t=null
inp.oninput = function(){
  if(t !== null){
    clearTimeout(t)
  }
  t = setTimeout(()=>{
    console.log(this.value)
  },500)
}

//优化：闭包
//消除了全局变量，同时让代码逻辑更清楚
let inp = document.querySelector("input")

inp.oninput = debpunce(function(){
  console.log(this.value) //这里this指向window
},500)


function debounce(callback,delay){
  let t=null
  return function(){
    if(t !== null){
      clearTimeout(t)
    }
    t = setTimeout(()=>{
      callback.call(this) //改变谁来调用fn
    },500)
  }
}
```



#### Map & Foreach

es5出现用于遍历数组

##### Map

