# React

#### 虚拟DOM

##### 虚拟dom是什么？[document object model]

+ 在js和真实dom中间加了一个个缓存，利用dom diff算法避免了没有必要的dom操作，提高了性能

##### 实现过程

+ 用JS对象结构表示dom树的结构

+ 用这个树构建一个真正的dom树,插到文档中当状态变更时, 重新构造一颗新的对象树

+ 新旧对象树比较, 记录差异并把差异应用到1所构建的真正的dom树上, 视图就更新了

#### 虚拟dom和dom的区别 性能差异

减少dom操作虚拟dom可以将多次dom操作合并为一次操作

| Real dom            | Virtual dom       |
| :------------------ | :---------------- |
| 更新慢              | 更新快            |
| 可以直接更新html    | 无法直接更新html  |
| 元素更新创建新dom树 | 元素更新则更新JSX |
| dom操作代价高       | DOM操作简单       |
| 消耗内存多          | 内存消耗小        |

#### React组件间通讯

| 六种方式           | 实现                                                 |
| ------------------ | ---------------------------------------------------- |
| 父组件=>子组件通讯 | props通讯                                            |
| 子组件=>父组件通讯 | props+回调                                           |
| 兄弟组件通讯       | 由共同父节点组件转发通讯                             |
| 跨层通讯           | Context对于一个组件树而言是全局的数据(主题/首选语言) |
| 发布订阅模式       | 发布者发布事件，订阅者监听事件，event模块通讯        |
| 全局状态管理       | 借助Redux维护全局状态中心Store                       |

#### Redux Context对比

和组件props相比，新旧的Context API和Redux都解决了props存在的“只要是子组件需要的信息，即使父组件不需要，也必须先传给父组件然后一层层传到子组件”的问题

与redux对比，context适合很少修改，主要从根节点下发数据的情形，比如locale/主题/个人登录信息

但至少Redux解决的以下问题，在Context API中仍然没有得到解决：

- **逻辑/数据/视图分离的代码结构**（reducer/store/component），很好地划分了代码职责
- **在不同项目之间通用的存储和事件机制**，从而允许[redux-devtools](https://www.zhihu.com/search?q=redux-devtools&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A319565629})和time travel这种通用的开发工具、以及类似redux-observable这种强大[中间件](https://www.zhihu.com/search?q=中间件&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A319565629})的存在（store/action）

#### Redux

管理全局变量的开发库

##### 数据如何流动？

+ 用户通过view发出action，发出方式为dispatch方法
+ store自动调用Reducer，并且传入两个参数: 当前state和收到的action，reducer返回新的state
+ state变化，store调用监听函数来更新view

##### Redux遵循的三个原则？

+ 单一数据源：整个应用的 state 被储存在一棵对象树中，并且这个 object tree 只存在于唯一一个 store 中。The global state of your application is stored in an object tree within a single store.开发和调试更容易
+ State是只读的：The only way to change the state is to emit an action, an object describing what happened. 唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。
+ 使用纯函数更改：为了描述 action 如何改变 state tree ，你需要编写 reducers。纯函数是那些返回值仅取决于其参数值的函数。

**你对“单一事实来源Single source of truth“有什么理解？**

Redux 使用 “Store” 将程序的整个状态存储在同一个地方。因此所有组件的状态都存储在 Store 中，并且它们从 Store 本身接收更新。单一状态树可以更容易地跟踪随时间的变化，并调试或检查程序。

**Redux 由以下组件组成：**

1. **Action** – 这是一个用来描述发生了什么事情的对象。
2. **Reducer** – 这是一个确定状态将如何变化的地方。
3. **Store** – 整个程序的状态/对象树保存在Store中。
4. **View** – 只显示 Store 提供的数据。

**如何在 Redux 中定义 Action？**

React 中的 Action 必须具有 type 属性，该属性指示正在执行的 ACTION 的类型。必须将它们定义为字符串常量，并且还可以向其添加更多的属性。在 Redux 中，action 被名为 Action Creators 的函数所创建。以下是 Action 和Action Creator 的示例：

```js
function addTodo(text) {
       return {
                type: ADD_TODO,    
                 text
    }
}
```

**解释 Reducer 的作用**

Reducers 是纯函数，它规定应用程序的状态怎样因响应 ACTION 而改变。Reducers 通过接受先前的状态和 action 来工作，然后它返回一个新的状态。它根据操作的类型确定需要执行哪种更新，然后返回新的值。如果不需要完成任务，它会返回原来的状态。

**Store 在 Redux 中的意义是什么？**

Store 是一个 JavaScript 对象，它可以保存程序的状态，并提供一些方法来访问状态、调度操作和注册侦听器。应用程序的整个状态/对象树保存在单一存储中。因此，Redux 非常简单且是可预测的。我们可以将中间件传递到 store 来处理数据，并记录改变存储状态的各种操作。所有操作都通过 reducer 返回一个新状态。

**Redux 有哪些优点？**

- 结果的可预测性 - 由于总是存在一个真实来源，即 store ，因此不存在如何将当前状态与动作和应用的其他部分同步的问题。
- 可维护性 - 代码变得更容易维护，具有可预测的结果和严格的结构。
- 服务器端渲染 - 你只需将服务器上创建的 store 传到客户端即可。这对初始渲染非常有用，并且可以优化应用性能，从而提供更好的用户体验。
- 开发人员工具 - 从操作到状态更改，开发人员可以实时跟踪应用中发生的所有事情。
- 社区和生态系统 - Redux 背后有一个巨大的社区，这使得它更加迷人。一个由才华横溢的人组成的大型社区为库的改进做出了贡献，并开发了各种应用。
- 易于测试 - Redux 的代码主要是小巧、纯粹和独立的功能。这使代码可测试且独立。
- 组织 - Redux 准确地说明了代码的组织方式，这使得代码在团队使用时更加一致和简单。

#### 防抖

减少用户触发，只要最后一次操作

```js
//有全局变量的方式
let inp = document.querySelector("input")
let t=null
inp.oninput = function(){
  if(t !== null){
    clearTimeout(t)
  }
  t = setTimeout(()=>{
    console.log(this.value)
  },500)
}

//优化：闭包
//消除了全局变量，同时让代码逻辑更清楚
let inp = document.querySelector("input")

inp.oninput = debpunce(function(){
  console.log(this.value) //这里this指向window
},500)


function debounce(callback,delay){
  let t=null
  return function(){
    if(t !== null){
      clearTimeout(t)
    }
    t = setTimeout(()=>{
      callback.call(this) //改变谁来调用fn
    },500)
  }
}
```



#### Map & Foreach

es5出现用于遍历数组

##### Map

